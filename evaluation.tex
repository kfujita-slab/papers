\chapter{評価と考察}
本章では、設計・実装したセマンティックセグメンテーションシステムの
性能を、資源使用量、最大動作周波数、レイテンシの観点から評価する
とともに、それらに関する考察を行う。
\section{評価}
評価にはVivadoによる論理合成結果と、計算によって求められるレイテンシ
を用いた。また、レイテンシ計算結果の正確度を検証するためverilogシミュレータであるxmverilogを利用する。
ネットワーク構成は図\ref{fig:segment_soft}に示す通りであり、$n=12$とした。
$n$の値はソフトウェアによる実装において良好な結果が得られたときの値を採用している。
\subsection{資源使用量}
論理合成によって得られた資源使用量を表\ref{tab:shiyou}に示す。
なお、DSP・BRAMについては最大限利用して合成を行うよう設定し、
溢れた分は他の資源を用いて合成される。DSPは主に固定小数の乗算に
、BRAMは主にFIFOを始めとするメモリに用いられる。
\begin{table}[hbt]
    \caption{資源使用量}
    \centering
    \resizebox{100mm}{!}{
    \begin{tabular}{crrr}
        \hline\hline
        資源    &\multicolumn{1}{c}{使用量}  & \multicolumn{1}{c}{使用可能} &\multicolumn{1}{c}{割合}     \\\hline
        LUT     & 2302985 &   537600 & 428.58\% \\\hline
        LUT-RAM &  140369 &    76800 & 182.77\% \\\hline
        FF      & 1732778 &  1075200 & 161.16\% \\\hline
        BRAM    &    1715 &     1728 &  99.25\% \\\hline
        DSP     &     752 &      768 &  97.92\% \\\hline
        CARRYs  & 306272  &    67200 & 455.76\% \\\hline
    \end{tabular}
    }
    \label{tab:shiyou}
\end{table}

\subsection{最大動作周波数}
最大動作周波数は、vivadoによる論理合成を行った際に生成される
Report Timing Summaryを利用する。
論理合成段階での判定であるため、
配置配線の結果によって変動する可能性のある値ではあるが、
動作可能周波数の目安として評価に利用した。

入力されるクロックを10ns\ (100MHz)としたときの、Report Timing Summary
から得られたWorst Nagative Slack (WNS)は5.111nsであった。
よって、論理合成時点での最大動作周波数は204.54MHzとなる。
%から得られたWorst Nagarive Slack (WNS)とともに、
%そこから求められる最大動作周波数と、
100MHz、最大動作周波数でそれぞれ駆動させたときのfps
を表\ref{tab:WNS}に示す。
なお、入出力画像のサイズは\ref{sec:algorithm}節と同じく
$640\times512$を想定する。
\begin{table}[hbt]
    \caption{動作周波数とfps}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        動作周波数& 100.00MHz &204.54MHz\\
        \hline
        fps       & 305.17fps &622.93fps\\
        \hline
    \end{tabular}
    \label{tab:WNS}
\end{table}

\subsection{レイテンシ}
システム全体のレイテンシ、つまり画素の入力から
対応した出力が行われるまでの経過クロック数は、
完全ストリーム処理である本実装では各モジュールのレイテンシの
総和で求めることができ、実行中に変化することもない。

本システムにおいて最もレイテンシを増加させる原因となるのは
フィルタ適用である。出力する注目画素をフィルタの中心とした場合、
フィルタ処理が行えるようになるのは右下画素が入力されてからなので、
注目画素の入力から約画像横幅分のレイテンシが必要となる。
さらに、本システムではpooling・unpoolingを行うため、これらの操作によって
も必要なレイテンシは変化する。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.9\textwidth,clip]{image/juyoya_image.pdf}
    \caption{出力1画素に対する受容野}
    \label{fig:juyoya_image}
\end{figure}
これらの処理によるレイテンシを計算するため、
最終的な1画素の出力に影響を与える範囲(受容野)を求める。
求めた受容野の大きさを図\ref{fig:juyoya_image}に示す。
また、求められた受容野から必要となるレイテンシを
図\ref{fig:juyoya_LATENCY}に示す。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.7\textwidth,clip]{image/juyoya_LATENCY.pdf}
    \caption{受容野から求められるレイテンシ}
    \label{fig:juyoya_LATENCY}
\end{figure}
よって、本システムのレイテンシには、少なくとも138.5行分のレイテンシが
存在することがわかった。ここに各処理における演算等のレイテンシが
加算されて全体のレイテンシとなる。

これを踏まえ、verilogシミュレーションであるxmverilogによって
全体のレイテンシを検証する。
また、波形表示と検証にはsimvisionを利用しており、その結果は
図\ref{fig:LATENCY_shot}の通りとなった。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=\textwidth,clip]{image/LATENCY_screen.png}
    \caption{シミュレーションによるレイテンシ解析}
    \label{fig:LATENCY_shot}
\end{figure}
クロックは10nsで駆動し、
end\_hcnt=0, end\_vcnt=0地点が最初の出力である。
in\_hcntとin\_vcntの値から
入力の座表値に対し$154\mathrm{行}+57$クロック分のレイテンシを経て出力されている
ことが読み取れる。
受容野から求めた行数に対し約15行分の差異が存在するが、
フィルタ処理以外の操作に必要なレイテンシを考慮した場合
約15行分の差異は妥当である。
%本システムにおいて最もレイテンシを増加させる原因となりうるのは
%フィルタ適用である。
%注目画素をフィルタの中心画素とした場合、結果が出力されるには
%右下画素の入力を待つ必要があり、フィルタ適用1回ごとに少なくとも
%画像横幅分のレイテンシが必要となる。
%さらに、本実装では有効画素の入力タイミングが変化することで、
%右下画素の入力を待つのに必要なクロックは指数関数的に増加する。
%図\ref{fig:LATENCY_gaizan}に各フィルタ適用に要する
%クロックを行単位で示す。実際にはニューロン数の違いなどで
%各フィルタ処理に必要なレイテンシは細かく変化する。
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=0.8\textwidth,clip]{image/LATENCY_gaizan.pdf}
%    \caption{フィルタ適用に要するレイテンシの概算(行)}
%    \label{fig:LATENCY_gaizan}
%\end{figure}
%
%図\ref{fig:LATENCY_gaizan}より、全体のレイテンシにおいて
%大きな割合を占めるであろうフィルタ処理に必要なレイテンシは、
%約139行分であることが概算的に求められた。
%これを踏まえ、verilogシミュレーションであるxmverilogによって
%全体のレイテンシを検証する。
%また、波形表示と検証にはsimvisionを利用しており、その結果は
%図\ref{fig:LATENCY_shot}の通りとなった。
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=\textwidth,clip]{image/LATENCY_screen.png}
%    \caption{シミュレーションによるレイテンシ解析}
%    \label{fig:LATENCY_shot}
%\end{figure}
%end\_hcnt=0, end\_vcnt=0地点が最初の出力である。
%入力の座表値に対し$154\mathrm{行}+57$クロック分のレイテンシを経て出力されている
%ことが読み取れる。
%概算で求めた行数に対し約15行分の差異が存在するが、
%フィルタ処理以外の操作に必要なレイテンシを考慮した場合
%約15行分の差異は妥当である。
\section{考察}
\subsection{現在の実装に対する評価について}
\label{sec:kosatsu_now}
表\ref{tab:shiyou}から分かる通り、
ほとんどの資源において資源使用量が使用可能量を超えているため、
現在の実装では1チップのFPGAに配置配線することが不可能である。
特に、LUTとCARRYsの使用量の割合が高く400\%を超えているが、
これは固定小数点乗算のために合成される大量の乗算器によるものが大半である。
表\ref{tab:Net_shiyou}に、各Netモジュールの各資源使用量を示す。
なお、RdcNet・ItgNetに関しては、
FIFOに用いるためのLUT\_RAM以外において、4つのネットワークでの資源使用量の差は
あまり見られないため、
それぞれLEVEL1における使用量を示している。

\begin{table}[hbt]
    \caption{各Netモジュールにおける資源使用量}
    \centering
    \resizebox{100mm}{!}{
    \begin{tabular}{crrrr}
        \hline\hline
        資源    &\multicolumn{1}{c}{ExtNet}  & \multicolumn{1}{c}{RdcNet} &\multicolumn{1}{c}{ItgNet} &\multicolumn{1}{c}{1$\times$1conv}     \\\hline
        LUT     &214974&256177&296603&1738 \\\hline
        DSP     &161   &36    &106   &21   \\\hline
        CARRYs  &25932 &32091 &37773 &226  \\\hline
    \end{tabular}
    }
    \label{tab:Net_shiyou}
\end{table}

しかし、本システムは完全ストリーム処理が可能な実装となっており、
モジュール間で渡される情報は、1クロックにつき1画素分の画素値・座標値・1bitの信号
のみである。
そのため、複数のFPGAを接続することによる実装は理論上可能であり、
FPGA間でのデータの受け渡しにかかるレイテンシも、そのデータ量から
性能を大きく低下させるほどではないと予想される。
複数のFPGAによる実装が可能となれば、本システムは仮に100MHzで駆動したとしても、
305.17\ fpsを達成し、かつ
約0.986msという低レイテンシでの動作が可能である。

また、\ref{sec:buf}節で述べたbufモジュールの実装方法によるメモリの増加
についてだが、
全体のレイテンシを求めたときと同様に
シミュレーションによる解析を行った結果、
単純なバッファリングによる実装に必要なレイテンシは
LEVEL0におけるbufモジュールで約148行分であった。
よって、必要なFIFOのメモリサイズは、画像1枚分のメモリを確保
している現在の実装に比べて3分の1以下に抑えることができる。
BRAM使用量の大半はbufモジュールで占められているため、
現在オーバーしているBRAM・LUT-RAMの使用量に関しては、
バッファリングによる実装に変更することによって
1チップ分の資源量に抑えられる可能性がある。
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=\textwidth,clip]{image/buf.png}
%    \caption{bufモジュールに必要なFIFOサイズ}
%    \label{fig:buf_LATENCY}
%\end{figure}

\subsection{1チップのFPGAによる実装に向けて}
%\ref{sec:kosatsu_now}節では、複数台のFPGAによる実装は可能である
%という旨について触れたが、
本項では、1チップのFPGAによる実装を目的として資源使用量の削減を行う場合、
どのような軽量化手法が効果的なのか考察を行う。

\subsubsection*{ネットワーク規模の縮小}
\ref{sec:kosatsu_now}節で述べた通り、本システムが資源量超過する原因は
大量の乗算器が合成されることにある。
各層における乗算数はニューロン数の2乗に比例するため、
ニューロン数を減少させることで資源量の大幅な削減が見込める。
%図\ref{fig:neuron_sum}にニューロン数の変化に伴う乗残数の変化を示す。
%各層におけるニューロンの数を$n=4$としたときの資源使用量を表\ref{tab:neuron4}
%に示す。
しかし、ネットワーク構成の大規模な変更はネットワークの出力精度に
大きく影響し、目的とする機能を構築できなくなる可能性が高い。
そのため、ネットワーク構成の変更による資源使用量削減は、
出力精度の観点から現実的でないといえる。

%次に考えられるのは、本プロジェクトにおけるネットワークの特徴ともいえる、
%小規模ネットワークの再帰的利用に着目した削減方法である。
\subsubsection*{ネットワークの再帰的利用に着目した削減方法}
本システムで利用されているネットワークは、\ref{sec:conv}節で述べた通り、
小規模ネットワークの再帰的利用を特徴とするネットワークである。
poolingによってLEVELが低くなるにつれ、
有効画素が入力されるタイミングは減少し、
それに伴って乗算器が動作しなければならないクロックも減少する。
そこで、乗算器が動作しないタイミングでは後段のネットワークとして動作
することで、ItgNetにおいては2つ、RdcNetにおいては1つの
ネットワークのみで全体の処理が可能となる。
これは、表\ref{tab:Net_shiyou}に示した通り各Netモジュールが
全体の資源使用量を占める本実装において、効果的な削減手法といえる。

\subsubsection*{量子化ニューラルネットワーク}
%資源使用量増加の原因である乗算の削減方法としては、
%重みパラメータの量子化が挙げられる。
量子化ニューラルネットワークは
2015年のBinaryConnect\cite{binary}を皮切りとして
様々な提案がされている手法である。
ここで用いる量子化とは、一般的に用いられることの多い
連続的な値を離散的な値に変換するという意味ではなく、
値の表現bit数を削減することを指す。
重みを1bitで表した場合、
積和演算を単純なビット演算に置き換えることができ乗算器の大幅な削減となる。
しかし、量子化ニューラルネットワークは、
比較的小さなネットワークでは良好な結果が得られやすいものの、
一般的な大きさのネットワークでは精度低下を引き起こしてしまうこと
が知られている。
そのため、本システムを量子化ニューラルネットワークとして実装する場合、
効果的な量子化手法の検証が重要になると考えられる。

\subsubsection*{separable convolutionの適用}
separable convolutionは、畳み込み演算を空間方向とチャネル方向に分離
させることで、パラメータ数と計算量を削減させる手法である。
図\ref{fig:separable}に、画像の大きさをF、フィルタの大きさをK、
チャネルの大きさをMとNとして出力例を示す。
画像左図が通常の畳み込み演算、画像右図がseparable convolutionを適用した
畳み込み演算である。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=\textwidth,clip]{image/separable.pdf}
    \caption{separable convolution}
    \label{fig:separable}
\end{figure}

また、それぞれの計算量は式\ref{siki_conv}・\ref{siki_separable}のように表される。
\begin{gather}
    \label{siki_conv}
    \mathrm{K}^2\mathrm{MN}\ \ \ \ \ \quad(通常の畳み込み)\\
    \label{siki_separable}
    \mathrm{K}^2\mathrm{M} + \mathrm{MN}\quad(\mathrm{separable\ convolution})
\end{gather}
KはNに比べて小さいため、計算量は約$1/\mathrm{K}^2$倍となる。
ソフトウェアにおいては、通常の畳み込みが最適化されているため
恩恵を受けにくいseparable convolutionだが、
FPGAをはじめとするハードウェアにおいては理論通りの資源量減少が
見込める。

%関連論文\cite{sample}.

%図の参照、図\ref{fig:yoshiki}
%
%表の参照、表\ref{tab:sample}
%
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[scale=1.0,clip]{image/yoshiki_nico.jpg}
%    \caption{Sample図}
%    \label{fig:yoshiki}
%\end{figure}
%
%
%\begin{table}[hbt]
%    \caption{Sample表}
%    \centering
%    \begin{tabular}{|c||c|c|c|c|c|}
%        \hline
%        & XXX & XX & XXXXX & XXXX & XXXX\\
%        \hline\hline
%        XXXX     & xxx & xxx & xxxx & xx & xx \\\hline
%        XXXXX & xxx & xxx & xxxx & xx & xx \\\hline   
%    \end{tabular}
%    \label{tab:sample}
%\end{table}

