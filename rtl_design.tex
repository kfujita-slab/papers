\section{設計と実装}
\label{rtl_design_top}
\ref{sec:algorithm}節で説明したシステムのハードウェア化にあたり、
外部からの入力画像は、順次走査により水平および垂直座標(hcnt,vcnt)と共に画素値(in\_pixel)のストリームとして与えられることを想定する。
それに伴い、出力は座標と共に4種類のクラスラベルが1画素ずつ返される。

FPGAへの実装は、Verilog HDLを用いたRTL記述にて行った。
論理合成にはVivado 2018.3を用い、ターゲットFPGAは
Virtex UltraScale xcvu095-ffva2104-2-eとした。
\subsection{システム構成}
\label{sec:system_design}
図\ref{fig:segment_soft}のネットワーク構成を基に、
図\ref{fig:segment_design}のような設計を行った。

\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.9\textwidth,clip]{image/segment_design.pdf}
    \caption{システム構成概略図}
    \label{fig:segment_design}
\end{figure}

システム全体は、順次走査により与えられる画像情報に対して、完全ストリーム処理を行うことができる設計となっている。畳み込み等のフィルタ演算は、適切なバッファリングにより切り出された
画素の周囲画像(パッチ)とフィルタを用いて、ツリー構造の演算器で
処理される。
ただし、pooling・unpoolingにより有効画素の出力タイミングが変化するため、
有効画素のタイミングを表すパラメータ(LEVEL)とイネーブル信号
によってストリーム処理を維持する。
LEVELは、図\ref{fig:LEVEL_design}に示す通り、毎クロック有効画素を出力するタイミングを
LEVEL0とし、タイミングが縦横それぞれ半分になる度に1,\ 2,\ ...と設定した。
なお、図\ref{fig:segment_design}に示したLEVELの区分については、
poolingモジュールは入力に対して、unpoolモジュールは出力に対して、
それ以外のモジュールでは入出力に対して図\ref{fig:LEVEL_design}に示したような
タイミングで動作する。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.9\textwidth,clip]{image/LEVEL_design.pdf}
    \caption{LEVELごとの有効画素変化}
    \label{fig:LEVEL_design}
\end{figure}

以下の項目では、ここに挙げた各モジュールについて、LEVELと
イネーブル信号による制御方法に触れながら、処理の設計と実装について詳細を述べる。
\subsection{stream\_patchモジュール}
\label{sec:patch}
畳み込み演算が行われる各モジュールとpoolingモジュール内では、パッチ切り出しの
ためのモジュール(stream\_patch)が用いられている。
有効画素の入力ごとに、フィルタに対応した大きさのパッチが切り出される様子を
図\ref{fig:stream_patch}に示す。
これにより、有効画素が入力されるクロックごとのフィルタ演算が可能となる。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.6\textwidth,clip]{image/patch.pdf}
    \caption{パッチ切り出し}
    \label{fig:stream_patch}
\end{figure}

\ref{sec:system_design}節で述べた通り、本システムではpooling・unpoolingによって有効画素のタイミングが変化する。
そこで、stream\_patchモジュールにイネーブル信号を追加し、
有効画素が入力されないクロック
ではFIFOを停止させることで、全体のストリーム処理を維持する設計とした。
stream\_patchモジュール内で用いられているバッファ用のメモリは、
Vivadoに組み込まれたIPカタログにより生成されたシンプルデュアルポートメモリである。
このメモリは書き込みイネーブルを入力に持つため、
0を入力することで図\ref{fig:stream_patch}に示したFIFOを停止させることができる。
よって、必要となるFIFOサイズは1行あたりの有効画素数となり、
画像横幅(WIDTH)とLEVELを用いた式\ref{LEVEL_WIDTH}によって決定される。
有効画素以外をメモリに格納する必要がないため、イネーブル制御を用いずに
FIFOを停止させない実装に比べ資源の消費量が少ない。
\begin{align}
    \mathrm{FIFOサイズ} = \mathrm{WIDTH}\div2^{\mathrm{LEVEL}}
    \label{LEVEL_WIDTH}
\end{align}
%というLEVELを用いた
%計算によって決定される。

また、stream\_patchモジュールが出力すべき座標値は、そのクロックで入力された座標値とstream\_patchモジュールのレイテンシを利用した計算によって求められる。
有効画素の入力タイミングの違いによりモジュールのレイテンシは変化するが、
必要とする有効画素の入力数は変化しないため、
基準となるLEVEL0のレイテンシ(LATENCY)と、
有効画素が入力される間隔を用いて、式\ref{LEVEL_LATENCY}のように
LEVELごとのレイテンシを求めることができる。
\begin{align}
\mathrm{stream\_patchモジュールのレイテンシ} = \mathrm{LATENCY}\times 2^{\mathrm{LEVEL}}
\label{LEVEL_LATENCY}
\end{align}

stream\_patchの変更により、フィルタ演算を行うモジュールは適切なイネーブル信号を
前段から受けとることで、有効画素のタイミング変化に対応できるようになった。各モジュール内での、その他の停止操作やイネーブル信号の出力方法については
以下の項目内にて詳細を述べる。

\subsection{ExtNet・RdcNet・ItgNetモジュール}
\ref{sec:conv}節で説明した通り、
本システムの畳み込み層は3種類の小規模ネットワークから構成されるため、
それぞれを別のモジュールとして3種類のモジュールを実装するが、
3種類のネットワークには積和演算や活性化関数の適用など共通する部分も多い。
そこで、図\ref{fig:NN_image}に表したような層間におけるニューロンの計算を、
共通モジュール(layerモジュール)として実装することで設計の単純化を狙う。
図\ref{fig:layer_image}にlayerモジュールによるネットワーク作成のイメージ図を示す。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.6\textwidth,clip]{image/layer_image.pdf}
    \caption{layerモジュールによるネットワーク作成イメージ}
    \label{fig:layer_image}
\end{figure}
layerモジュールはパラメータによって、内部のニューロンの数を変更でき、
layerを重ねることで、多段ネットワークを実装する。
よって、ネットワーク全体の入出力、layerモジュールを呼び出す段数、各layerモジュールの
パラメータの変更を行うことで、今回実装するExtNet,\ RdcNet,\ ItgNet,\ 1$\times$1\_convの各Netモジュールが実装可能となる。

layerモジュールについて説明する。layerモジュールは$n$チャネルの画素をそれぞれ1画素ずつ受け取り、
stream\_patchモジュールによってパッチに切り出した後、
畳み込み演算、バイアス加算、活性化関数の適用を行う。
畳み込みにおける加算器ツリーについて、
フィルタの一辺の長さ(FLT\_SIZE)を3、
前段のニューロン数(PREV\_NEURONS)を3、
後段のニューロン数(NEW\_NEURONS)を2
としたときの例を図\ref{fig:add_tree}に示す。
layerモジュールが出力する座標値は、stream\_patchモジュールが出力する
座標値と、畳み込み演算と活性化関数の適用に必要なレイテンシによって求められる。
畳み込み演算のレイテンシは、パッチあたりの画素数$(\mathrm{PATCH\_NUM = FLT\_SIZE}^2)$と、前段のニューロン数(PREV\_NEURONS)に依存し、式\ref{layer_LATENCY}のように求められる。
\begin{align}
    \mathrm{畳み込み演算のレイテンシ} =\lceil \log{_2}(\mathrm{PATCH\_NUM}\times\mathrm{PREV\_NEURONS})\rceil
    \label{layer_LATENCY}
\end{align}
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{image/add_tree_change.pdf}
    \caption{加算器ツリーによる畳み込み演算}
    \label{fig:add_tree}
\end{figure}

\noindent また、layerモジュールが出力するイネーブル信号については、
自身のLEVELと自らが出力する座標値を利用した
有効画素判定によって信号の値を決定できる。
図\ref{fig:LEVEL_design}を基にして設定された、LEVELによって注目すべき座標値のビット幅を
決定する判定方法を表\ref{tab:layer_enable}に示す。
\begin{table}[hbt]
    \caption{出力座標値とLEVELによる有効画素判定(layerモジュール)}
    \centering
    \begin{tabular}{l|c}
        
        & イネーブル信号値\\
        \hline
        LEVEL0    & 1'b1\\
        LEVEL$N$($N\neq0$) & (\&hcnt[$N-1:0]$)\ \&\&\ (\&vcnt[$N-1:0]$)\\
    \end{tabular}
    \label{tab:layer_enable}
\end{table}
%\ref{sec:patch}節で述べたように、各Netモジュールは前段からのイネーブル信号を
%stream\_patchモジュールに渡すことで、モジュールを停止させることができる。
%出力すべき画素の座標値は、stream\_patchが出力する座標値をlayerモジュール内での
%畳み込み演算
%また、入力としてイネーブル信号を受け取り、
%ストリームパッチモジュールに渡すことで動作制御する。また、自身の
%レイテンシ分遅延させて出力することで、後段のlayerまたは次のモジュールのイネーブル信号とする。
%画素の水平座標(以下h\_cnt)と垂直座標(以下v\_cnt)に関しても、
%layerモジュールが受け取り、
%適切な遅延が行われて出力される。
%DSP推論、溢れ分をロジックで実装する話を書く予定です。
%それよりも、積和演算方法についてかいたほうがいいんでない
\subsection{poolingモジュール}
\label{sec:pooling_design}
poolingモジュールもlayerモジュールと同じく、stream\_patchモジュールを用いて
対象画素の入力ごとに動作できる。
ここで用いる対象画素とは、今回$2\times2$ max poolingを適用するため、
画像全体を$2\times2$の領域で区切った際の各領域の右下画素のことである。
右下画素が入ったタイミングでpoolingを行い、
イネーブル信号と合わせて出力を行う。
切り出されたパッチ内の最大値を求めるツリーを、
ニューロンの数が3のときを例として図\ref{fig:pooling_tree}に示す。
図\ref{fig:pooling_tree}からわかる通り、
poolingに必要なレイテンシはlayerモジュールのようにニューロンの数
で変化することはない。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.5\textwidth,clip]{image/pooling_tree.pdf}
    \caption{ツリーによるpooling}
    \label{fig:pooling_tree}
\end{figure}

layerモジュールと同じく、出力するイネーブル信号の値は、
自身のLEVELと出力する座標値を用いた判定によって決定できる。
しかし、poolingモジュールは入力に対して出力を縦横半分にする、
つまりLEVELを上げる処理を行うため、出力するイネーブル信号の判定は
1大きいLEVELを用いて行う必要があり、
%ここでは、自身のLEVELという表現に注意しておきたい。
%\ref{sec:system_design}節で述べた通り、
%poolingモジュール内で扱われるLEVELの値は入力を基準に与えられているが、
%poolingモジュールは、入力に対して出力を縦横それぞれ半分にするため、
%いわばLEVELを上げる処理を行っているといえる。
%そのため、出力するイネーブル信号の判定はLEVELが変化するという前提で行う必要があり、
同LEVELのlayerモジュールの判定とは違ったものとなる。
表\ref{tab:pool_enable}にその判定方法を示す。
表\ref{tab:layer_enable}と見比べると、LEVELの用い方に
違いがあることが確認できる。
\begin{table}[hbt]
    \caption{出力座標値とLEVELによる有効画素判定(poolingモジュール)}
    \centering
    \begin{tabular}{l|c}
        
        & イネーブル信号値\\
        \hline
        LEVEL$N$ & (\&hcnt[$N:0]$)\ \&\&\ (\&vcnt[$N:0]$)\\
    \end{tabular}
    \label{tab:pool_enable}
\end{table}

%\noindent 右下画素であることは、layerモジュール
%における出力判定と同じく、
%自身のLEVELと座標値によって判定することができる。
%表\ref{tab:pool_enable}にその判定方法を示す。poolingモジュールは
%出力が入力に対して縦横それぞれ半分になることから、
%同じLEVELの各Netモジュールの出力に対して
%\begin{itemize}
%\item\ if\ (\ h\_cnt[0] == 1 \&\& v\_cnt[0] == 1\ )
%\end{itemize}
%また、座標値(h\_cnt,v\_cnt)の出力はサイズの変化に合わせて適切に変更される必要がある。
%\ref{sec:pooling}節で述べた通り、各poolingモジュールの出力サイズは入力に
%対して縦横それぞれ半分となるので、下位1ビットを切り捨てればよい。
%この画像サイズ縮小に伴い、後段のモジュールにおける
%有効画素が入るタイミングが変化する。図\ref{fig:pooling_clock}にその様子を示す。
%左図は毎クロック有効画素を出力しているのに対し、poolingモジュールの
%適用ごとに有効画素を出力するクロックが減少していることがわかる。
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=0.8\textwidth,clip]{image/pooling_clock.pdf}
%    \caption{有効画素が出力されるクロック数の変化}
%    \label{fig:pooling_clock}
%\end{figure}
%ただし、畳み込み処理とは違い、フィルタサイズ2$\times$2に対してストライド2であるため、
%出力は毎クロック有効でなく、2$\times$2で区切られた領域の右下画素入力に合わせて
%有効となる。
%そこで、本モジュールでは出力時の座標を利用し、有効出力を表すイネーブル信号を出力する。
%また、pooling処理自身も前段のpooling処理の影響から動作回数が変化するため、
%イネーブル信号を受け取り、ストリームパッチを停止させる。
%このような実装とすることで、モジュールの変更を行うことなく、
%再帰的なプーリング層の適用を実現した。
%
%画像サイズを縮小させる性質から、h\_cntとv\_cntはともに適切な変更が
%行われる必要がある。各段でそれぞれ大きさが半分になるので、
%出力有効画素における座標値の下位1ビットを切り捨てる実装とした。

%最大値プーリングの計算方法を図\ref{fig:pooling_method}に示す。

\subsection{unpoolingモジュール}
\label{sec:unpooling_design}
\ref{sec:unpooling}節で述べたように、
本システムにおける
unpooling動作は単純な画素拡張操作であるため、
入力画素のバッファリングによって実装する。
前段からの有効画素に対して、図\ref{fig:unpooling_design}のように
拡張を行うが、実際に入力される有効画素の座標値はpoolingモジュールにおける
操作から、区切られた領域内での右下画素である。
つまり、unpoolingは区切られた領域内の右下の画素を受け取り、
新たに設定された各領域の右下へと拡張する操作といえる。
図\ref{fig:unpooling_image}にunpoolingモジュールで行われる操作のイメージ図を示す。
これを基に、必要となるバッファリングの大きさ、出力する座標値、イネーブル信号
を適切に設定する。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.6\textwidth,clip]{image/unpooling_image.pdf}
    \caption{LEVELによるunpoolingモジュール動作イメージの変化}
    \label{fig:unpooling_image}
\end{figure}

まず、座標値についてだが、右下の有効画素が入力されてはじめて、
左上方向への拡張が可能になる。
したがって、入力される有効画素の座標値に対し、式\ref{unpool_outcnt}
で表されるだけのレイテンシが存在するとみなす。このレイテンシを基に
出力する座標値を計算することで、入力される右下の座標値から出力する
左上の座標値を求めることができる。
\begin{align}
    \mathrm{LATENCY} = \mathrm{WIDTH} \times (2^\mathrm{LEVEL})+1
    \label{unpool_outcnt}
\end{align}

%この事から、unpoolingモジュールは、有効画素が入力されたタイミングで左上方向への
%拡張を行う動作になったといえる。これを基準として、他方向への拡張に必要な
%バッファの大きさを決定する。以下に残りの3方向の拡張に必要なバッファの大きさを
%LEVELを用いた式によって示す。
入力された画素を拡張された左上の画素とみなす場合、残りの3画素については
適切な大きさのバッファを通して出力すればよい。
適切な大きさのバッファはLEVELを用いた式で以下のように表せる。

\begin{itemize}
\item 右上方向 : UppR\_BUF = $2^{\mathrm{LEVEL}}$
\item 左下方向 : LowL\_BUF = $2^{\mathrm{LEVEL}} \times$WIDTH(入力画像横幅)
\item 右下方向 : LowR\_BUF = UppR\_BUF + LowL\_BUF
\end{itemize}
これにより、すべての拡張方向に対する適切なバッファの大きさを設定できた。
このバッファリングされた画素値と、出力する座標値による拡張方向選択を組み合わせることによって、現在のタイミングで出力すべき拡張方向の画素値を出力する。
表\ref{tab:unpooling_select0}にLEVEL0のとき、
表\ref{tab:unpooling_selectN}にそれ以外のLEVELのときの
拡張方向の選択方法をそれぞれ示す。
\begin{table}[hbt]
    \caption{拡張方向選択方法：LEVEL0}
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        hcnt[0]==0 & hcnt[0]==1 & hcnt[0]==0 & hcnt[0]==1 \\
        vcnt[0]==0 & vcnt[0]==0 & vcnt[0]==1 & vcnt[0]==1 \\
        \hline\hline
        左上出力 & 右上出力 & 左下出力 & 右下出力\\\hline 
    \end{tabular}
    \label{tab:unpooling_select0}
\end{table}
\begin{table}[hbt]
    \caption{拡張方向選択方法：$\mathrm{LEVEL}\neq$0}
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tabular}{|c||c|c|c|c|}
        \hline
        &hcnt[LEVEL]==0 & hcnt[LEVEL]==1 & hcnt[LEVEL]==0 & hcnt[LEVEL]==1 \\
        &vcnt[LEVEL]==0 & vcnt[LEVEL]==0 & vcnt[LEVEL]==1 & vcnt[LEVEL]==1 \\
        \hline\hline
        ((\&hcnt[LEVEL-1:0])\&\&     &\multirow{2}{*}{左上出力} & \multirow{2}{*}{右上出力} & \multirow{2}{*}{左下出力}& \multirow{2}{*}{右下出力}\\
        (\&vcnt[LEVEL-1:0]))==1 & & & &     \\\hline
        otherwise &  \multicolumn{4}{c|}{出力なし}\\ \hline   
    \end{tabular}}
    \label{tab:unpooling_selectN}
\end{table}

\ref{sec:system_design}節で述べた通り、unpoolingのLEVELは出力を基準に設定されている。
そのため、出力イネーブル信号の出力はlayerモジュールで用いた表\ref{tab:layer_enable}に
よる判定によって同様に決定される。
%
%右上、左下、右下に拡張するにあたり、バッファの大きさを適切に決定する必要があるが、
%図\ref{fig:LEVEL_design}に示すように、unpoolingの適用回数による
%有効出力タイミングの変化は規則的であるため、適用回数を基としたパラメータによって
%バッファの大きさを決定することとした。
%このパラメータをLEVELとし、元々の入力画像と同じサイズに変化する際、
%つまり毎クロック有効画素を出力する
%unpoolingのLEVELを0、以降を1...2...と設定する。
%LEVELに基づいて決定されるバッファの大きさを以下に示す。これにより、
%unpoolingモジュールはパラメータとしてLEVELを設定するだけで
%再帰的な利用が可能な設計となった。
%\begin{itemize}
%\item 右上 : UppR\_BUF = $2^{\mathrm{LEVEL}}$
%\item 左下 : LowL\_BUF = $2^{\mathrm{LEVEL}} \times$WIDTH(入力画像横幅)
%\item 右下 : LowR\_BUF = UppR\_BUF + LowL\_BUF
%\end{itemize}
%%\begin{figure}[hbt]
%%    \centering
%%    \includegraphics[width=0.8\textwidth,clip]{image/unpooling_clock.pdf}
%%    \caption{有効画素の出力タイミングとバッファサイズの変化}
%%    \label{fig:unpooling_clock}
%%\end{figure}
%
%画素の出力順は4方向の循環ではなく、行ごとに動作が
%有効画素が入力される行では左上・右上画素が、
%$2^\mathrm{LEVEL}\times$WIDTH後の行では左下・右下画素が出力される。
%そこで、前段からのイネーブル信号、バッファ分のカウント、行判定によって
%遷移するステートマシンとしての設計を行った。図\ref{fig:unpooling_state}に
%状態遷移図を示す。
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=0.7\textwidth,clip]{image/unpooling_state.pdf}
%    \caption{状態遷移図}
%    \label{fig:unpooling_state}
%\end{figure}
%
%イネーブル信号で遷移する待機状態を初期状態とする。
%外部からのイネーブル信号によって左上に遷移。
%バッファ用のメモリに画素値を渡し、左上の出力を行う。
%その後、カウンタによってLEVELに基づくバッファ分待機し、右上に遷移する。
%右上はメモリから画素値を受けとり出力。同じくカウンタによってバッファ分待機し、
%左上に再び遷移する。これを1行分繰り返す。なお、行の終了も出力間の
%待機と同じようにカウンタを用いて判定している。
%1行終了後、出力行判定で遷移する待機状態へと遷移する。
%ここで用いる出力行判定とは、
%左下・右下画素の出力を開始する行を判定することを指し、
%判定にはLEVELを用いた。左上・右上画素の出力行を0行目とした場合、
%左下・右下画素の出力行は$2^\mathrm{LEVEL}$行目となる。そこで、
%1行終了が判定された回数を用いて、出力行判定を行った。
%その後、左下・右下も左上・右上と同様に、
%遷移を繰り返しながら1行分の出力を行い、
%1行終了後イネーブル信号によって遷移する待機状態に戻る。
%図\ref{fig:unpooling_state_image}にLEVELごとの状態遷移イメージを示す。
%外部からの入力のタイミングでin\_vcnt[0]が変化しているが、
%これを利用してカウントを同期させている。
%%バッファリングされる行数は2のべき乗であることから、
%%v\_cnt[LEVEL]の値が変化した瞬間が出力される行の開始点である。
%%図\ref{fig:unpooling_state_image}にLEVELごとの状態遷移イメージをv\_cntの値と
%%ともに示す。v\_cnt[LEVEL]の値が変化した際に出力が開始されているのが確認できる。
%%左下・右下も同様に、遷移を繰り返しながら1行分の出力を行う。
%%その後、イネーブル信号によって遷移する待機状態に戻る。
%
%\begin{figure}[hbt]
%    \centering
%    \includegraphics[width=0.9\textwidth,clip]{image/unpooling_state_image.pdf}
%    \caption{LEVELごとの状態遷移イメージ}
%    \label{fig:unpooling_state_image}
%\end{figure}
%
%また、poolingモジュールと同様に、座標値(h\_cnt,v\_cnt)の出力は
%サイズの変化に合わせて適切に変更される必要がある。
%\ref{sec:unpooling}節で述べた通り、各unpoolingモジュールのサイズは
%入力に対してそれぞれ2倍となるので、適切な値による下位1ビットの拡張を行えばよい。
%図\ref{fig:unpooling_state_image}、
%表\ref{tab:unpooling_bit}に拡張方向に基づく座標値の変更方法を示す。
%\begin{table}[hbt]
%    \caption{拡張方向に基づく座標値の変更}
%    \centering
%    \begin{tabular}{|l||c|c|}
%        \hline
%        &左：h\_cntは元画素と同じ&右：h\_cntは元画素+1\\
%        \hline\hline
%        \multirow{2}{*}{上：v\_cntは元画素と同じ}& h\_cnt 0ビット拡張 &h\_cnt 1ビット拡張\\
%                                & v\_cnt 0ビット拡張 &v\_cnt 0ビット拡張\\\hline
%        \multirow{2}{*}{下：v\_cntは元画素+1} & h\_cnt 0ビット拡張 & h\_cnt 1ビット拡張 \\
%                                & v\_cnt 1ビット拡張 &v\_cnt 1ビット拡張\\\hline
%    \end{tabular}
%    \label{tab:unpooling_bit}
%\end{table}
%
%バッファリングの大きさは自身の動作回数によって決定される。
%図\ref{fig:unpooling_level}のように、動作回数が多いほどバッファリングは小さく、
%動作回数が少ないほどバッファリングは大きくなる。
%そこで、この動作回数の変化をレベルと呼ぶパラメータで表し、それを基にバッファリングの
%大きさを決定した、具体的な値は以下の通りである。
%
%\begin{itemize}
%\item 右上 : UppR\_BUF = 1 $<<$ LEVEL
%\item 左下 : LowL\_BUF = (1 $<<$ LEVEL) * WIDTH(画像横幅)
%\item 右下 : LowR\_BUF = UppR\_BUF + LowL\_BUF
%\end{itemize}
%
%また、図\ref{fig:unpooling_level}におけるバッファリングの表現は、
%あくまで1クロックに1画素の出力を行うレベル0における動作を基準にしており、
%各段におけるunpoolingの動作は前段からの入力を水平・垂直方向
%に2倍する動作であることに留意しておきたい。
%
%\begin{figure}[H]
%    \centering
%    \includegraphics[width=10cm,clip]{image/unpooling_level.pdf}
%    \caption{本システムにおけるunpooling動作}
%    \label{fig:unpooling_level}
%\end{figure}
%
%このような実装により、パラメータであるレベルの値以外の変更なく、
%unpoolingモジュールを再帰的に適用できる。
%
%また、前段からの有効出力1画素を複数画素に拡散する特性から、前段のイネーブル信号と
%バッファリングの大きさ、画像領域によって遷移するステートマシンとして実装を行った。
%イネーブル信号は出力を行う状態で有効となる。
%拡張に伴うh\_cntとv\_cntの変更は、左上、右上、左下、右下の値出力を行う
%状態において、以下のように適切な拡張が行われる。
%\begin{itemize}
%\item 左上 : h\_cnt 1ビット0拡張, v\_cnt 1ビット0拡張
%\item 右上 : h\_cnt 1ビット1拡張, v\_cnt 1ビット0拡張
%\item 左下 : h\_cnt 1ビット0拡張, v\_cnt 1ビット1拡張
%\item 右下 : h\_cnt 1ビット1拡張, v\_cnt 1ビット1拡張
%\end{itemize}
%
%
%%図\ref{fig:unpooling_state}に状態遷移図を示す。
%
%出力のイネーブル信号は画素出力に合わせて有効になる。そのため前段と比べ後段の動作回数
%が増加するが、増減値はpoolingにおける変化と一致し、最終的には最初の動作回数と同等になる。
%よってストリーム処理が崩れることはない。
%
\subsection{bufモジュール}
\label{sec:buf}
bufモジュールは、ItgNetモジュールが受け取るunpoolingモジュールからの出力と
pooling層適用前の特徴マップを対応付ける機能を持つ。
通常ならば、それぞれの特徴マップ出力に必要なレイテンシの差分を求め、
差分だけバッファリングさせることで出力のタイミングを合わせるのが一般的である。

一方で、本研究における実装はニューロン数やネットワーク段数など、
パラメータによるネットワーク変更が可能な設計がされている。
これはネットワークの改良に対して柔軟に対応するための設計であるが、
レイテンシの差分だけバッファリングする方法では、
パラメータによるネットワーク変更を行う度に
レイテンシを正確に求める必要があり、煩雑な設計が求められる。
%フィルタ演算を始めとする処理の差異が多く、
%レイテンシの差分を正確に求めるのが困難である。
そこで、画像1枚分のメモリを確保し、座標値(hcnt,vcnt)に基づくアドレスに
よって対応付けることとした。図\ref{fig:buf_address}にbufモジュールの設計を示す。
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.9\textwidth,clip]{image/buf_addr.pdf}
    \caption{bufモジュール}
    \label{fig:buf_address}
\end{figure}

out\_hcnt,\ out\_vcntには各ItgNetモジュール前段のunpoolingモジュールの出力が渡される。
これにより、unpoolingモジュールからの画素値と同じ座標値を持つ
pooling前の画素値を対応付けることができた。
ただし、この実装方法は一般的なバッファリングによる実装方法に比べて
資源使用量が増加することが予想される。\ref{sec:kosatsu_now}節で
バッファリングに必要な資源量と実際の資源使用量を比較した考察を行うこととする。


%この設計は、正確なレイテンシ分だけバッファリングさせるものに比べて、
%余分なメモリを確保することとなる。しかし、FPGAがBRAMによってメモリを
%確保するときの大きさはある程度決まっており、今回余分に確保する分に関しては
%BRAMの使用量を大幅に変化させることはないと予想した。
%ずらす方法とか

